package conoha

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/k0kubun/pp"
	"github.com/rackspace/gophercloud/openstack/networking/v2/extensions/security/groups"
	"github.com/rackspace/gophercloud/openstack/networking/v2/extensions/security/rules"
	"github.com/rackspace/gophercloud/openstack/networking/v2/ports"
)

const (
	// Security group name and descritpion for conoha-net
	SEC_GROUP_NAME        = "conoha-net"
	SEC_GROUP_DESCRIPTION = "Generated by conoha-net."

	// Specity the system created security groups and prefix
	SYSTEM_SECGROUP_DEFAULT = "default"
	SYSTEM_SECGROUP_PREFIX  = "gncs"
)

type Port struct {
	PortId      string
	IPv4Address string
	IPv6Address string
}

// Create a security group rule and return UUID
type Rule struct {
	Direction      string
	EtherType      string
	PortRange      string
	Protocol       string
	RemoteGroupID  string
	RemoteIPPrefix string
}

func (r *Rule) ToCreateOpts() (rules.CreateOpts, error) {
	opts := rules.CreateOpts{}

	// validation
	if r.Direction == "ingress" || r.Direction == "egress" {
		opts.Direction = r.Direction
	} else {
		return opts, fmt.Errorf(`"direction" must be either "ingress" or "egress"`)
	}

	if r.EtherType == "IPv4" || r.EtherType == "IPv6" {
		opts.EtherType = r.EtherType
	} else {
		return opts, fmt.Errorf(`"ether-type" must be either "IPv4" or "IPv6"`)
	}

	if r.Protocol == "tcp" ||
		r.Protocol == "udp" ||
		r.Protocol == "icmp" {
		opts.Protocol = r.Protocol
	} else if r.Protocol == "all" {
		r.Protocol = ""
	} else {
		return opts, fmt.Errorf(`invalid protocol`)
	}

	if r.PortRange != "" {
		m, err := regexp.MatchString(`^[0-9]+\:[0-9]+$`, r.PortRange)
		if err != nil {
			return opts, err

		} else if m {
			ps := strings.Split(r.PortRange, ":")
			opts.PortRangeMin, _ = strconv.Atoi(ps[0])
			opts.PortRangeMax, _ = strconv.Atoi(ps[1])

		} else {
			p, err := strconv.Atoi(r.PortRange)
			if err != nil {
				return opts, fmt.Errorf("Invalid format of PortRange. [%s]", r.PortRange)
			}
			opts.PortRangeMin = p
			opts.PortRangeMax = p
		}

		// Must specify the protocol if port range is given.
		if opts.Protocol == "" {
			return opts, fmt.Errorf("Must specify the protocol if port range is given.")
		}
	}

	if r.RemoteGroupID != "" {
		opts.RemoteGroupID = r.RemoteGroupID
	}

	if r.RemoteIPPrefix != "" {
		opts.RemoteIPPrefix = r.RemoteIPPrefix
	}
	return opts, nil
}

func CreateRule(os *OpenStack, name string, rule Rule) (*rules.SecGroupRule, error) {
	opts, err := rule.ToCreateOpts()
	if err != nil {
		return nil, err
	}

	// Detect the security group
	group, err := GetGroup(os, name)
	if err != nil {
		return nil, err
	}
	opts.SecGroupID = group.ID

	pp.Printf("%v\n", opts)

	rt := rules.Create(os.Network, opts)
	if rt.Err != nil {
		return nil, rt.Err
	}
	return rt.Extract()
}

// List the user created security groups.
func ListGroup(os *OpenStack) ([]groups.SecGroup, error) {
	opts := groups.ListOpts{}
	pager := groups.List(os.Network, opts)
	if pager.Err != nil {
		return nil, pager.Err
	}

	page, err := pager.AllPages()
	if err != nil {
		return nil, err
	}

	return groups.ExtractGroups(page)
}

func GetGroup(os *OpenStack, name string) (*groups.SecGroup, error) {
	sgs, err := ListGroup(os)
	if err != nil {
		return nil, err
	}

	for _, g := range sgs {
		if g.ID == name || g.Name == name {
			return &g, nil
		}
	}

	return nil, fmt.Errorf("Can't found the security group. [%s]", name)
}

// Remove the system security groups from allgroups
func RemoveSystemGroups(allgroups []groups.SecGroup) []groups.SecGroup {
	ugs := make([]groups.SecGroup, 0, len(allgroups))
	for _, g := range allgroups {
		if g.Name != SYSTEM_SECGROUP_DEFAULT && !strings.HasPrefix(g.Name, SYSTEM_SECGROUP_PREFIX) {
			ugs = append(ugs, g)
		}
	}

	return ugs[0:len(ugs)]
}

func CreateGroup(os *OpenStack, name string, description string) error {
	opts := groups.CreateOpts{
		Name:        name,
		Description: description,
	}
	rt := groups.Create(os.Network, opts)
	if rt.Err != nil {
		return rt.Err
	}
	return nil
}

func DeleteGroup(os *OpenStack, name string) error {
	group, err := GetGroup(os, name)
	if err != nil {
		return err
	}

	rt := groups.Delete(os.Network, group.ID)
	if rt.Err != nil {
		return rt.Err
	}
	return nil
}

func Attach(os *OpenStack, vps *Vps, groupName string) error {
	sgs, err := ListGroup(os)
	if err != nil {
		return err
	}

	secGroupIds := make([]string, 0, len(vps.SecurityGroups))
	for _, g := range vps.SecurityGroups {
		secGroupIds = append(secGroupIds, g.ID)
	}

	var ok bool
	for _, sg := range sgs {
		if sg.Name == groupName || sg.ID == groupName {
			secGroupIds = append(secGroupIds, sg.ID)
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("Security group not found. [%s]", groupName)
	}

	opts := ports.UpdateOpts{
		SecurityGroups: secGroupIds,
	}
	rs := ports.Update(os.Network, vps.Ports[0].PortId, opts)
	if rs.Err != nil {
		return rs.Err
	}
	return nil
}

func Detach(os *OpenStack, vps *Vps, groupName string) error {
	var ok bool

	secGroupIds := make([]string, 0, len(vps.SecurityGroups))
	for _, sg := range vps.SecurityGroups {
		if sg.Name == groupName || sg.ID == groupName {
			ok = true
			continue
		} else {
			secGroupIds = append(secGroupIds, sg.ID)
		}
	}
	if !ok {
		return fmt.Errorf("Security group not found. [%s]", groupName)
	}

	opts := ports.UpdateOpts{
		SecurityGroups: secGroupIds,
	}
	rs := ports.Update(os.Network, vps.Ports[0].PortId, opts)
	if rs.Err != nil {
		return rs.Err
	}
	return nil
}

// // Initialize a security group
// func initializeSecurityGroup(os *OpenStack, vps Vps) error {
// 	pager := groups.List(os.Network, groups.ListOpts{})

// 	hasConoHaNet := false
// 	pager.EachPage(func(page pagination.Page) (bool, error) {
// 		egs, err := groups.ExtractGroups(page)
// 		if err != nil {
// 			return false, err
// 		}

// 		for _, g := range egs {
// 			if g.Name == SEC_GROUP_NAME {
// 				n.group = g
// 				hasConoHaNet = true
// 				break
// 			}
// 		}
// 		return true, nil
// 	})

// 	if hasConoHaNet {
// 		return nil
// 	}

// 	// Create security group and assign it to VM if not exists
// 	copts := groups.CreateOpts{
// 		Name:        SEC_GROUP_NAME,
// 		Description: SEC_GROUP_DESCRIPTION,
// 	}

// 	rt := groups.Create(os.Network, copts)
// 	if rt.Err != nil {
// 		return rt.Err
// 	}

// 	var sec struct {
// 		SecGroup secgroups.SecurityGroup `mapstructure:"security_group" json:"security_group"`
// 	}
// 	err := mapstructure.Decode(rt.Body, &sec)
// 	if err != nil {
// 		return err
// 	}

// 	uopts := ports.UpdateOpts{
// 		SecurityGroups: []string{sec.SecGroup.ID},
// 	}

// 	rs := ports.Update(os.Network, vps.Ports[0].PortId, uopts)
// 	if rs.Err != nil {
// 		return rs.Err
// 	}
// 	return nil
// }

// func ModifyRules(os *OpenStack, vps Vps) error {
// 	var err error
// 	if err = n.initializeSecurityGroup(vps); err != nil {
// 		return err
// 	}

// 	opts := rules.CreateOpts{
// 		Direction:      "ingress",
// 		EtherType:      "IPv4",
// 		SecGroupID:     n.group.ID,
// 		PortRangeMax:   10000,
// 		PortRangeMin:   1,
// 		Protocol:       "tcp",
// 		RemoteIPPrefix: "210.172.128.0",
// 	}

// 	rs := rules.Create(os.Network, opts)
// 	if rs.Err != nil {
// 		return rs.Err
// 	}

// 	return nil
// }
